![TOML Logo](logos/toml-200.png)

TOML v1.0.0
===========

トムの明瞭で最小の言語。

By Tom Preston-Werner, Pradyun Gedam, et al.

目的
----------

TOML は、明白なセマンティクスによって読みやすい最小限の設定ファイルフォーマットとなることを目的につくられました。TOML は、ハッシュテーブルに一義的に対応するように設計されていて、さまざまな言語のデータ構造に展開できます。

目次
-----------------

- [仕様](#仕様)
- [コメント](#コメント)
- [キーと値のペア](#キーと値のペア)
- [キー](#キー)
- [文字列](#文字列)
- [整数](#整数)
- [浮動小数点数](#浮動小数点数)
- [ブール値](#ブール値)
- [オフセット付き日時](#オフセット付き日時)
- [ローカルの日時](#ローカルの日時)
- [ローカルの日付](#ローカルの日付)
- [ローカルの時間](#ローカルの時間)
- [配列](#配列)
- [テーブル](#テーブル)
- [インライン テーブル](#インライン-テーブル)
- [テーブルの配列](#テーブルの配列)
- [ファイル名の拡張子](#ファイル名の拡張子)
- [MIME タイプ](#MIME-タイプ)
- [ABNF 文法](#ABNF-文法)

仕様
----

* TOML はケース・センシティブです。大文字と小文字は区別されます。
* TOML ファイルはユニコード (UTF-8) でエンコードされている必要があります。
* 空白はタブ (0x09) もしくはスペース (0x20) のことです。
* 改行は LF (0x0A) もしくは CRLF (0x0D 0x0A) のことです。

コメント
-------

ハッシュ記号（`#`）に続けて改行までをコメントとします。
ただし、文字列の内部はコメントになりません。

```toml
# この行は全てコメントです。
key = "value"  # 行末までコメントです。
another = "# これはコメントではありません"
```

タブ以外の制御文字 (U+0000 から U+0008、 U+000A から U+001F、および U+007F) はコメント内では使用できません。

キーと値のペア
--------------

TOML 文書の主要な構成要素は、キーと値のペアです。

キーは等号（`=`）の左に、値は右に記述します。
キー名と値の周りにある空白は無視されます。
キー、等号、および値は同じ行になければなりません (ただし、一部の値は複数行にまたがることができます)。

```toml
key = "value"
```

値は、以下のいずれかのタイプでなければなりません。

- [文字列](#文字列)
- [整数](#整数)
- [浮動小数点数](#浮動小数点数)
- [ブール値](#ブール値)
- [オフセット付き日時](#オフセット付き日時)
- [ローカルの日時](#ローカルの日時)
- [ローカルの日付](#ローカルの日付)
- [ローカルの時刻](#ローカルの時刻)
- [配列](#配列)
- [インライン テーブル](#インライン-テーブル)

未定義の値は無効となります。

```toml
key = # 無効
```

キーと値のペアの後には改行 (または EOF) が必要です。
(例外については、[インライン テーブル](#インライン テーブル) を参照してください。)

```toml
first = "Tom" last = "Preston-Werner" # 無効
```

キー
----

キーは、ベアキー、引用符付きキー、またはドット付きキーのいずれかです。

**ベアキー** には、ASCII 文字、ASCII 数字、アンダースコア、およびダッシュ (`A-Za-z0-9_-`) のみを含めることができます。
ここで、たとえベアキーは ASCII 数字のみからなっていても (例: `1234`)、常に文字列として解釈されます。

```toml
key = "value"
bare_key = "value"
bare-key = "value"
1234 = "value"
```

**引用符付きキー** は、基本文字列またはリテラル文字列とまったく同じルールに従い、より広範なキー名のセットを使用できます。
ベストプラクティスは、絶対に必要な場合を除いて、ベアキーを使用することです。

```toml
"127.0.0.1" = "value"
"character encoding" = "value"
"ʎǝʞ" = "value"
'key2' = "value"
'quoted "value"' = "value"
```

ベアキーは空であってはなりませんが、引用符で囲まれた空のキーは許可されます (ただし、非推奨)。

```toml
= "no key name"  # 無効
"" = "blank"     # 有効ですが推奨されません
'' = 'blank'     # 有効ですが推奨されません
```

**ドット付きキー** は、ベアキーまたは引用符付きキーがドット (`.`) でつながったものです。
これにより、同様のプロパティを以下のようにグループ化できます。

```toml
name = "Orange"
physical.color = "orange"
physical.shape = "round"
site."google.com" = true
```

JSON で記述すると、上記のデータは以下のような構造になります。

```json
{
  "name": "Orange",
  "physical": {
    "color": "orange",
    "shape": "round"
  },
  "site": {
    "google.com": true
  }
}
```

ドット付きキーが定義するテーブルの詳細については、以下の [テーブル](#テーブル) のセクションを参照してください。

ドットで区切られた部分の周囲の空白は無視されます。
しかし、ベストプラクティスは、余計な空白を使わないことです。

```toml
fruit.name = "banana"       # これがベストプラクティスです
fruit. color = "yellow"     # fruit.color と同じです
fruit . flavor = "banana"   # fruit.flavor と同じです
```

インデントは空白として扱われ、無視されます。

キーを複数回定義することは無効です。

```toml
# 以下のような記述をしないでください
name = "Tom"
name = "Pradyun"
```

ベアキーと引用符付きキーは等価であることに注意してください。

```toml
# 以下の記述は動作しません
spelling = "favorite"
"spelling" = "favourite"
```

キーが直接定義されていない限り、そのキーやその中の名前に書き込むことができます。

```toml
# これにより、キー「フルーツ」がテーブルになります。
fruit.apple.smooth = true

# したがって、以下のようにテーブルに「フルーツ」を追加できます。
fruit.orange = 2
```

```toml
# 以下のコードは、無効です

# 以下は、fruit.apple の値が整数になるように定義しています。
fruit.apple = 1

# しかし、以下の行では、fruit.apple をテーブルのように扱っています。
# 整数をテーブルに変換することはできません。
fruit.apple.smooth = true
```

ドット付きキーを順不同で定義することはお勧めできません。

```toml
# 有効ですが、推奨されません

apple.type = "fruit"
orange.type = "fruit"

apple.skin = "thin"
orange.skin = "thick"

apple.color = "red"
orange.color = "orange"
```

```toml
# こちらの方が推奨されます

apple.type = "fruit"
apple.skin = "thin"
apple.color = "red"

orange.type = "fruit"
orange.skin = "thick"
orange.color = "orange"
```

ベアキーは ASCII 整数のみで構成できるため、浮動小数点のように見えるような 2 つの部分からなるドット付きキーを記述できます。 
正当な理由がない限り (おそらくないでしょう)、これを行わないでください。

```toml
3.14159 = "pi"
```

上記の TOML は、以下の JSON にマッピングされます。

```json
{ "3": { "14159": "pi" } }
```

文字列
------

文字列を記述するには、基本文字列、複数行基本文字列、リテラル文字列、複数行リテラル文字列の 4 つの方法があります。
すべての文字列には、有効な UTF-8 文字のみが含まれている必要があります。

**基本文字列** は、引用符 (`"`) で囲まれます。
エスケープする必要がある引用符、バックスラッシュ、およびタブ以外の制御文字 (U+0000 ～ U+0008、U+000A ～ U+001F、U+007F) を除く、任意の Unicode 文字を使用できます。

```toml
str = "I'm a string. \"You can quote me\". Name\tJos\u00E9\nLocation\tSF."
```

利便性のために、いくつかの文字についてはエスケープシーケンスの短縮形が用意されています。

```
\b         - backspace       (U+0008)
\t         - tab             (U+0009)
\n         - linefeed        (U+000A)
\f         - form feed       (U+000C)
\r         - carriage return (U+000D)
\"         - quote           (U+0022)
\\         - backslash       (U+005C)
\uXXXX     - unicode         (U+XXXX)
\UXXXXXXXX - unicode         (U+XXXXXXXX)
```

Unicode 文字はすべて、`\uXXXX` または `\UXXXXXXX` 形式でエスケープできます。
エスケープ コードは有効な Unicode [スカラー値](https://unicode.org/glossary/#unicode_scalar_value) である必要があります。

上記にリストされていない他のエスケープ シーケンスはすべて予約されています。 
これらを使用すると、TOML はエラーを生成するはずです。

場合によっては、テキストの一節 (翻訳ファイルなど) を表現する必要がある場合や、非常に長い文字列を複数の行に分割したい場合があります。 TOML を使用するとこれが簡単になります。

**複数行基本文字列** は、両側を 3 つの引用符で囲み、改行を許可します。
開始デリミタの直後の改行は削除されます。
その他のすべての空白文字と改行文字はそのまま残ります。

```toml
str1 = """
Roses are red
Violets are blue"""
```

TOML パーサーは、改行をプラットフォームにとって意味のあるものに自由に正規化する必要があります。

```toml
# Unix システムでは、上記の複数行文字列は多くの場合以下と同等になるでしょう。
str2 = "Roses are red\nViolets are blue"

# Windows システムでは、多くの場合以下とほぼ同等になるでしょう。
str3 = "Roses are red\r\nViolets are blue"
```

無関係な空白が含まれないように長い文字列を記述するには、「行末バックスラッシュ」を使用します。
行の最後の非空白文字がエスケープされていない `\` である場合、次の非空白文字または終了区切り文字までのすべての空白文字 (改行を含む) が削除されます。
基本文字列に有効なエスケープ シーケンスはすべて、複数行基本文字列にも有効です。

```toml
# 以下の 3 つの文字列は、バイト単位で等価です。
str1 = "The quick brown fox jumps over the lazy dog."

str2 = """
The quick brown \


  fox jumps over \
    the lazy dog."""

str3 = """\
       The quick brown \
       fox jumps over \
       the lazy dog.\
       """
```

Unicode 文字は、エスケープが必要なバックスラッシュと、タブ、改行、キャリッジリターン以外の制御文字 (U+0000 ～ U+0008、U+000B、U+000C、U+000E ～ U+001F、U+007F) を使用できます。

複数行基本文字列内のどこにでも、引用符、または隣接する 2 つの引用符を書くことができます。デリミタ (`"""`) のすぐ内側に記述することもできます。

```toml
str4 = """引用符2つ: ""。簡単ですね。"""
# str5 = """引用符3つ: """。"""  # 無効
str5 = """引用符3つ: ""\"。"""
str6 = """引用符15個: ""\"""\"""\"""\"""\"。"""

# "This," she said, "is just a pointless statement."
str7 = """"This," she said, "is just a pointless statement.""""
```

Windows のパスや正規表現を頻繁に指定する場合、バックスラッシュをエスケープするのはすぐに面倒になり、エラーが発生しやすくなります。
そこで TOML は、エスケープを一切許さないリテラル文字列をサポートしています。

**リテラル文字列** は一重引用符で囲まれます。 
基本文字列と同様に、これらは 1 行で記述する必要があります。

```toml
# 表示されている文字列、そのものが得られます。
winpath  = 'C:\Users\nodejs\templates'
winpath2 = '\\ServerX\admin$\system32\'
quoted   = 'Tom "Dubs" Preston-Werner'
regex    = '<\i\c*\s*>'
```

エスケープがないため、一重引用符で囲まれたリテラル文字列の中に一重引用符を記述することはできません。 
幸いなことに、TOML はこの問題を解決するリテラル文字列の複数行バージョンをサポートしています。

**複数行リテラル文字列** は、両側を 3 つの一重引用符で囲み、改行も使用できます。 
リテラル文字列と同様に、エスケープはまったくありません。
開始デリミタの直後の改行は削除されます。 
デリミタの間にある他のすべての内容は、変更せずにそのまま解釈されます。

```toml
regex2 = '''I [dw]on't need \d{2} apples'''
lines  = '''
生の文字列では、
最初の改行は取り除かれます。
   その他の空白は、
   保持されます。
'''
```

複数行リテラル文字列内の任意の場所に 1 つまたは 2 つの一重引用符を記述することができますが、3 つ以上の一重引用符の連続は許可されません。

```toml
quot15 = '''Here are fifteen quotation marks: """""""""""""""'''

# apos15 = '''Here are fifteen apostrophes: ''''''''''''''''''  # 無効
apos15 = "Here are fifteen apostrophes: '''''''''''''''"

# 'That,' she said, 'is still pointless.'
str = ''''That,' she said, 'is still pointless.''''
```

タブ以外の制御文字はリテラル文字列では許可されません。 
したがって、バイナリデータの場合は、Base64 または別の適切な ASCII または UTF-8 エンコードを使用することをお勧めします。
そのエンコーディングの処理はアプリケーション固有になります。

整数
-------

整数とは、小数部のない数のことです。
正の数値の前にプラス記号を付けることができます (が、付けなくても構いません)。
負の数値には、マイナス記号を接頭辞として付けます。

```toml
int1 = +99
int2 = 42
int3 = 0
int4 = -17
```

数値が大きい場合は、読みやすくするために桁と桁の間にアンダースコアを使用できます。
各アンダースコアの両側には、1 桁以上の数字が必要です。

```toml
int5 = 1_000
int6 = 5_349_221
int7 = 53_49_221  # インド式命数法
int8 = 1_2_3_4_5  # 有効ですが推奨されません
```

先行ゼロは許可されません。
整数値 `-0` と `+0` は有効で、接頭辞のないゼロと同じです。

負でない整数値は、16 進数、8 進数、または 2 進数で表現できます。
これらの形式では、接頭辞 `+` は使用できませんが、 (接頭辞の後に) 先行ゼロがあっても構いません。 16 進値では大文字と小文字が区別されません。
桁と桁の間ではアンダースコアを使用できます (ただし、接頭辞と値の間では使用できません)。

```toml
# 接頭辞 `0x` が付いた 16 進数
hex1 = 0xDEADBEEF
hex2 = 0xdeadbeef
hex3 = 0xdead_beef

# 接頭辞 `0o` が付いた 8 進数
oct1 = 0o01234567
oct2 = 0o755 # Unix ファイルのパーミッションに便利

# 接頭辞 `0b` が付いた 2 進数
bin1 = 0b11010110
```

任意の 64 ビット符号付き整数 (-2^63 から 2^63-1) を受け入れ、ロスレスで処理する必要があります。
整数をロスレスで表現できない場合は、エラーをスローする必要があります。

浮動小数点数
-----

浮動小数点数は、IEEE 754 binary64 値として実装する必要があります。

浮動小数点数は、整数部分 (10 進整数値と同じ規則に従います) と、その後に続く小数部分および/または指数部分で構成されます。
小数部と指数部の両方が存在する場合は、小数部を指数部よりも前に置く必要があります。

```toml
# 小数部
flt1 = +1.0
flt2 = 3.1415
flt3 = -0.01

# 指数部
flt4 = 5e+22
flt5 = 1e06
flt6 = -2E-2

# 少数部と指数部の両方
flt7 = 6.626e-34
```

小数部は、小数点の後に 1 つ以上の数字が続くものです。

指数部は E (大文字または小文字) の後に整数部が続くものです (10 進整数値と同じ規則に従いますが、先行ゼロが含まれていてもよいです)。

小数点を使用する場合は、その両側に 1 桁以上の数字が必要です。

```toml
# 無効な浮動小数点数
invalid_float_1 = .7
invalid_float_2 = 7.
invalid_float_3 = 3.e+20
```

整数と同様に、読みやすさを高めるためにアンダースコアを使用できます。 
各アンダースコアの両側には 1 桁以上の数字が必要です。

```toml
flt8 = 224_617.445_991_228
```

浮動小数点値 `-0.0` および `+0.0` は有効であり、IEEE 754 に従ってマッピングされる必要があります。

特殊な浮動小数点数の値も表現できます。 これらは常に小文字です。

```toml
# 無限大
sf1 = inf  # 正の無限大
sf2 = +inf # 正の無限大
sf3 = -inf # 負の無限大

# 非数 (NaN)
sf4 = nan  # 実際の sNaN/qNaN エンコーディングは実装に依存します
sf5 = +nan # `nan` と等価
sf6 = -nan # 有効で、実際のエンコーディングは実装に依存します
```

ブール値
-------

ブール値は、よくあるトークンそのままです。 常に小文字です。

```toml
bool1 = true
bool2 = false
```

オフセット付き日時
----------------

特定の時刻を明確に表現するには、[RFC 3339](https://tools.ietf.org/html/rfc3339) オフセット付きでフォーマットされた日付/時刻を使うことができます。

```toml
odt1 = 1979-05-27T07:32:00Z
odt2 = 1979-05-27T00:32:00-07:00
odt3 = 1979-05-27T00:32:00.999999-07:00
```

読みやすくするために、日付と時刻の間の `T` デリミタを空白文字に置き換えることができます ([RFC 3339](https://tools.ietf.org/html/rfc3339) セクション 5.6 で許可されている)。

```toml
odt4 = 1979-05-27 07:32:00Z
```

少なくともミリ秒の精度が保存される必要がありますが、それ以上の精度は実装に依存します。
実装がサポートできるよりも高い精度が値に含まれている場合、追加の精度は四捨五入ではなく切り捨てる必要があります。

ローカルの日時
---------------

[RFC 3339](https://tools.ietf.org/html/rfc3339) でフォーマットされた日時からオフセットを省略すると、オフセットやタイムゾーンとは関係なく、指定された日時が表されます。
追加情報がなければ、それを特定の瞬間を表すデータに変換できません。
そのような変換が必要な場合は、実装依存となります。

```toml
ldt1 = 1979-05-27T07:32:00
ldt2 = 1979-05-27T00:32:00.999999
```

少なくともミリ秒の精度が保存される必要がありますが、それ以上の精度は実装に依存します。
実装がサポートできるよりも高い精度が値に含まれている場合、追加の精度は四捨五入ではなく切り捨てる必要があります。

ローカルの日付
----------

[RFC 3339](https://tools.ietf.org/html/rfc3339) でフォーマットされた日時の日付部分のみを含めると、オフセットやタイムゾーンに関係なく、その日全体を表すことになります。

```toml
ld1 = 1979-05-27
```

ローカルの時間
----------

[RFC 3339](https://tools.ietf.org/html/rfc3339) でフォーマットされた日時の時刻部分のみを含めると、特定の日やオフセット、タイムゾーンとは関係なく、その日の時刻を表すことになります。

```toml
lt1 = 07:32:00
lt2 = 00:32:00.999999
```

少なくともミリ秒の精度が保存される必要がありますが、それ以上の精度は実装に依存します。
実装がサポートできるよりも高い精度が値に含まれている場合、追加の精度は四捨五入ではなく切り捨てる必要があります。

配列
-----

配列は角括弧の中に複数の値が入ったものです。 空白は無視されます。 要素はカンマで区切られます。 
配列には、キーと値のペアで許可されているのと同じデータ型の値を含めることができます。
異なるデータ型の値が混在していてもよいです。

```toml
integers = [ 1, 2, 3 ]
colors = [ "red", "yellow", "green" ]
nested_arrays_of_ints = [ [ 1, 2 ], [3, 4, 5] ]
nested_mixed_array = [ [ 1, 2 ], ["a", "b", "c"] ]
string_array = [ "all", 'strings', """are the same""", '''type''' ]

# 異なるデータ型の値を混在させることができます
numbers = [ 0.1, 0.2, 0.5, 1, 2, 5 ]
contributors = [
  "Foo Bar <foo@example.com>",
  { name = "Baz Qux", email = "bazqux@example.com", url = "https://example.com/bazqux" }
]
```

配列は複数行にまたがることができます。
配列の最後の値の後には、終了カンマ (末尾カンマとも呼ばれる) を使用できます。
任意の数の改行とコメントを値、カンマ、閉じ括弧の前に置くことができます。
配列値とカンマの間のインデントは空白として扱われ、無視されます。

```toml
integers2 = [
  1, 2, 3
]

integers3 = [
  1,
  2, # 最後の行末の `,` は有効です
]
```

テーブル
-----

テーブル (ハッシュテーブルや辞書とも呼ばれる) は、キーと値のペアの集まりです。
これらはヘッダーによって定義され、行に角括弧が単独で配置されます。
配列は値としてのみ出現するため、ヘッダーと配列は識別可能です。

```toml
[table]
```

その下、次のヘッダーまたは EOF までが、そのテーブルのキーと値のペアです。
テーブル内のキーと値のペアは、特定の順序であることは保証されません。

```toml
[table-1]
key1 = "some string"
key2 = 123

[table-2]
key1 = "another string"
key2 = 456
```

テーブルの命名規則はキーの場合と同じです (上記の [キー](#キー) の定義を参照)。

```toml
[dog."tater.man"]
type.name = "pug"
```

JSON で記述すると、上記のデータは以下のような構造になります。

```json
{ "dog": { "tater.man": { "type": { "name": "pug" } } } }
```

キーの周囲の空白は無視されます。 ただし、ベストプラクティスは、無関係な空白を使用しないことです。

```toml
[a.b.c]            # これがベストプラクティスです
[ d.e.f ]          # [d.e.f] と同じです
[ g .  h  . i ]    # [g.h.i] と同じです
[ j . "ʞ" . 'l' ]  # [j."ʞ".'l'] と同じです
```

インデントは空白として扱われ、無視されます。

必要がない場合は、すべての上位テーブルを指定する必要はありません。 TOML が代わりにやっておきます。

```toml
# [x] 4行目を有効にするために、
# [x.y] 1行目から3行目までを
# [x.y.z] 指定する必要はありません
[x.y.z.w]

[x] # 後から上位テーブルを定義しても問題ありません
```

空のテーブルは許可されますが、テーブル内にキーと値のペアが存在しないだけです。

キーと同様に、テーブルを複数回定義することはできません。 そうすることは無効です。

```toml
# 以下のような記述をしないでください

[fruit]
apple = "red"

[fruit]
orange = "orange"
```

```toml
# 以下のような記述もしないでください

[fruit]
apple = "red"

[fruit.apple]
texture = "smooth"
```

テーブルを順不同で定義することは推奨されません。

```toml
# 有効ですが推奨されません
[fruit.apple]
[animal]
[fruit.orange]
```

```toml
# こちらが推奨されます
[fruit.apple]
[fruit.orange]
[animal]
```

最上位のテーブルはルートテーブルとも呼ばれ、ドキュメントの先頭から始まり、最初のテーブル ヘッダー (または EOF) の直前で終わります。
他のテーブルとは異なり、名前がなく、再配置できません。

```toml
# 最上位テーブルが始まります。
name = "Fido"
breed = "pug"

# 最上位テーブルが終了します。
[owner]
name = "Regina Dogman"
member_since = 1999-08-04
```

ドット付きキーは、そのようなテーブルが事前に作成されていない場合、最後のキー部分の前に各キー部分のテーブルを作成および定義します。

```toml
fruit.apple.color = "red"
# fruit という名前のテーブルを定義します
# fruit.apple という名前のテーブルを定義します

fruit.apple.taste.sweet = true
# fruit.apple.taste という名前のテーブルを定義します
# fruit と fruit.apple はすでに作成されています
```

テーブルは複数回定義できないため、`[table]` ヘッダーを使用してそのようなテーブルを再定義することはできません。
同様に、`[table]` 形式で既に定義されているテーブルを再定義するためにドットキーを使用することも許可されていません。 
ただし、`[table]` 記法は、ドットキーで定義されたテーブル内のサブテーブルを定義するために使用できます。

```toml
[fruit]
apple.color = "red"
apple.taste.sweet = true

# [fruit.apple]  # 無効
# [fruit.apple.taste]  # 無効

[fruit.apple.texture]  # サブテーブルは追加できます
smooth = true
```

インライン テーブル
------------

インライン テーブルは、テーブルを表現するためのよりコンパクトな構文を提供します。
これらは、グループ化されたデータがすぐに冗長になってしまう可能性がある場合に特に役立ちます。
インライン テーブルは波括弧 `{` と `}` 内で完全に定義されます。
波括弧の中には、カンマで区切られたキーと値のペアを 0 個以上入れることができます。
キーと値のペアは、標準テーブルのキーと値のペアと同じ形式になります。
インライン テーブルを含む、すべての値の型が許可されます。

インライン テーブルは 1 行で表示されるように設計されています。
インライン テーブル内の最後のキーと値のペアの後には、終了カンマ (末尾のカンマとも呼ばれる) を使用することはできません。
基本的に、波括弧の間に改行を入れることはできません。 
例外は、値の中に改行が含まれる場合です。
もっとも、インライン テーブルが複数行にまたがることは強く推奨されません。
このような欲求にとらわれている場合は、標準テーブルを使用する必要があることを意味します。

```toml
name = { first = "Tom", last = "Preston-Werner" }
point = { x = 1, y = 2 }
animal = { type.name = "pug" }
```

上記のインライン テーブルは、次の標準テーブルの定義と同じです。

```toml
[name]
first = "Tom"
last = "Preston-Werner"

[point]
x = 1
y = 2

[animal]
type.name = "pug"
```

インライン テーブルは完全に自己完結型であり、その中にすべてのキーとサブテーブルが定義されます。
キーとサブテーブルを波括弧の外側に追加することはできません。

```toml
[product]
type = { name = "Nail" }
# type.edible = false  # 無効
```

同様に、インライン テーブルを使用して、すでに定義されているテーブルにキーやサブテーブルを追加することはできません。

```toml
[product]
type.name = "Nail"
# type = { edible = false }  # 無効
```

テーブルの配列
---------------

まだ説明されていない最後の構文では、テーブルの配列を書き込むことができます。
これらは、名前を二重括弧で囲んだヘッダーを使用して表現できます。
そのヘッダーの最初のインスタンスは配列とその最初のテーブル要素を定義し、後続の各インスタンスはその配列内に新しいテーブル要素を作成して定義します。
テーブルは、表記された順序で配列に挿入されます。

```toml
[[products]]
name = "Hammer"
sku = 738594937

[[products]]  # 配列内の空のテーブル

[[products]]
name = "Nail"
sku = 284758393

color = "gray"
```

JSON で記述すると、上記のデータは以下のような構造になります。

```json
{
  "products": [
    { "name": "Hammer", "sku": 738594937 },
    { },
    { "name": "Nail", "sku": 284758393, "color": "gray" }
  ]
}
```

テーブルの配列への参照は、配列の最後に定義されたテーブル要素を指します。
これにより、直前のテーブル内にサブテーブル、さらにはテーブルのサブ配列を定義できるようになります。

```toml
[[fruits]]
name = "apple"

[fruits.physical]  # サブテーブル
color = "red"
shape = "round"

[[fruits.varieties]]  # ネストされたテーブル配列
name = "red delicious"

[[fruits.varieties]]
name = "granny smith"


[[fruits]]
name = "banana"

[[fruits.varieties]]
name = "plantain"
```

上記の TOML は、以下の JSON にマッピングされます。

```json
{
  "fruits": [
    {
      "name": "apple",
      "physical": {
        "color": "red",
        "shape": "round"
      },
      "varieties": [
        { "name": "red delicious" },
        { "name": "granny smith" }
      ]
    },
    {
      "name": "banana",
      "varieties": [
        { "name": "plantain" }
      ]
    }
  ]
}
```

テーブルまたはテーブルの配列の親が配列要素である場合、子を定義する前にその要素がすでに定義されている必要があります。
この順序を逆にしようとすると、解析時にエラーが発生する必要があります。

```toml
# 無効な TOML ドキュメント
[fruit.physical]  # サブテーブルですが、どの親要素に属すべきでしょうか?
color = "red"
shape = "round"

[[fruit]]  # パーサーは "fruit" がテーブルではなく配列であることを発見したときにエラーをスローする必要があります
name = "apple"
```

静的に定義された配列に追加しようとすると、その配列が空であっても、解析時にエラーが発生する必要があります。

```toml
# 無効な TOML ドキュメント
fruits = []

[[fruits]] # 許可されていません
```

すでに定義された配列と同じ名前の通常のテーブルを定義しようとすると、解析時にエラーが発生する必要があります。
通常のテーブルを配列として再定義しようとすると、同様に解析時エラーが発生する必要があります。

```toml
# 無効な TOML ドキュメント
[[fruits]]
name = "apple"

[[fruits.varieties]]
name = "red delicious"

# 無効: このテーブルは前のテーブルの配列と競合しています
[fruits.varieties]
name = "granny smith"

[fruits.physical]
color = "red"
shape = "round"

# 無効: このテーブルの配列は前のテーブルと競合します
[[fruits.physical]]
color = "green"
```

必要に応じて、以下のようなインライン テーブルを使用することもできます。

```toml
points = [ { x = 1, y = 2, z = 3 },
           { x = 7, y = 8, z = 9 },
           { x = 2, y = 4, z = 8 } ]
```

ファイル名の拡張子
------------------

TOML ファイルには拡張子 `.toml` を使用する必要があります。

MIME タイプ
---------

TOML ファイルをインターネットで転送する場合、適切な MIME タイプは `application/toml` です。

ABNF 文法
------------

TOML 構文の正式な説明は、別の [ABNF ファイル][abnf] として入手できます。

[abnf]: https://github.com/toml-lang/toml/blob/1.0.0/toml.abnf
