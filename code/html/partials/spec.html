<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="spec">Spec</h2>
<ul class="list-disc list-inside my-4" $1>
<li>TOML is case sensitive.</li>
<li>A TOML file must be a valid UTF-8 encoded Unicode document.</li>
<li>Whitespace means tab (0x09) or space (0x20).</li>
<li>Newline means LF (0x0A) or CRLF (0x0D 0x0A).</li>
</ul>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="comment">Comment</h2>
<p class="my-4" $1>A hash symbol marks the rest of the line as a comment, except when inside a string.</p>
<pre><code class="code language-toml" data-controller="snippet"># This is a full-line comment
key = &quot;value&quot;  # This is a comment at the end of a line
another = &quot;# This is not a comment&quot;
</code></pre>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="key-value-pair">Key/Value Pair</h2>
<p class="my-4" $1>The primary building block of a TOML document is the key/value pair.</p>
<p class="my-4" $1>Keys are on the left of the equals sign and values are on the right. Whitespace
is ignored around key names and values. The key, equals sign, and value must be
on the same line (though some values can be broken over multiple lines).</p>
<pre><code class="code language-toml" data-controller="snippet">key = &quot;value&quot;
</code></pre>
<p class="my-4" $1>Values must be of the following types: String, Integer, Float, Boolean,
Datetime, Array, or Inline Table. Unspecified values are invalid.</p>
<pre><code class="code language-toml" data-controller="snippet">key = # INVALID
</code></pre>
<p class="my-4" $1>There must be a newline after a key/value pair.
(See <a href="#user-content-inline-table">Inline Table</a> for exceptions.)</p>
<pre><code>first = &quot;Tom&quot; last = &quot;Preston-Werner&quot; # INVALID
</code></pre>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="keys">Keys</h2>
<p class="my-4" $1>A key may be either bare, quoted or dotted.</p>
<p class="my-4" $1><strong>Bare keys</strong> may only contain ASCII letters, ASCII digits, underscores, and
dashes (<code>A-Za-z0-9_-</code>). Note that bare keys are allowed to be composed of only
ASCII digits, e.g. <code>1234</code>, but are always interpreted as strings.</p>
<pre><code class="code language-toml" data-controller="snippet">key = &quot;value&quot;
bare_key = &quot;value&quot;
bare-key = &quot;value&quot;
1234 = &quot;value&quot;
</code></pre>
<p class="my-4" $1><strong>Quoted keys</strong> follow the exact same rules as either basic strings or literal
strings and allow you to use a much broader set of key names. Best practice is
to use bare keys except when absolutely necessary.</p>
<pre><code class="code language-toml" data-controller="snippet">&quot;127.0.0.1&quot; = &quot;value&quot;
&quot;character encoding&quot; = &quot;value&quot;
&quot;ʎǝʞ&quot; = &quot;value&quot;
'key2' = &quot;value&quot;
'quoted &quot;value&quot;' = &quot;value&quot;
</code></pre>
<p class="my-4" $1>A bare key must be non-empty, but an empty quoted key is allowed (though
discouraged).</p>
<pre><code class="code language-toml" data-controller="snippet">= &quot;no key name&quot;  # INVALID
&quot;&quot; = &quot;blank&quot;     # VALID but discouraged
'' = 'blank'     # VALID but discouraged
</code></pre>
<p class="my-4" $1><strong>Dotted keys</strong> are a sequence of bare or quoted keys joined with a dot. This
allows for grouping similar properties together:</p>
<pre><code class="code language-toml" data-controller="snippet">name = &quot;Orange&quot;
physical.color = &quot;orange&quot;
physical.shape = &quot;round&quot;
site.&quot;google.com&quot; = true
</code></pre>
<p class="my-4" $1>In JSON land, that would give you the following structure:</p>
<pre><code class="code language-json" data-controller="snippet">{
  &quot;name&quot;: &quot;Orange&quot;,
  &quot;physical&quot;: {
    &quot;color&quot;: &quot;orange&quot;,
    &quot;shape&quot;: &quot;round&quot;
  },
  &quot;site&quot;: {
    &quot;google.com&quot;: true
  }
}
</code></pre>
<p class="my-4" $1>Whitespace around dot-separated parts is ignored, however, best practice is to
not use any extraneous whitespace.</p>
<p class="my-4" $1>Defining a key multiple times is invalid.</p>
<pre><code># DO NOT DO THIS
name = &quot;Tom&quot;
name = &quot;Pradyun&quot;
</code></pre>
<p class="my-4" $1>Since bare keys are allowed to compose of only ASCII integers, it is possible
to write dotted keys that look like floats but are 2-part dotted keys. Don't do
this unless you have a good reason to (you probably don't).</p>
<pre><code class="code language-toml" data-controller="snippet">3.14159 = &quot;pi&quot;
</code></pre>
<p class="my-4" $1>The above TOML maps to the following JSON.</p>
<pre><code class="code language-json" data-controller="snippet">{ &quot;3&quot;: { &quot;14159&quot;: &quot;pi&quot; } }
</code></pre>
<p class="my-4" $1>As long as a key hasn't been directly defined, you may still write to it and
to names within it.</p>
<pre><code>a.b.c = 1
a.d = 2
</code></pre>
<pre><code># THIS IS INVALID
a.b = 1
a.b.c = 2
</code></pre>
<p class="my-4" $1>Defining dotted keys out-of-order is discouraged.</p>
<pre><code class="code language-toml" data-controller="snippet"># VALID BUT DISCOURAGED

a.type = ''
b.type = ''

a.name = ''
b.name = ''

a.data = ''
b.data = ''
</code></pre>
<pre><code class="code language-toml" data-controller="snippet"># RECOMMENDED

a.type = ''
a.name = ''
a.data = ''

b.type = ''
b.name = ''
b.data = ''
</code></pre>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="string">String</h2>
<p class="my-4" $1>There are four ways to express strings: basic, multi-line basic, literal, and
multi-line literal. All strings must contain only valid UTF-8 characters.</p>
<p class="my-4" $1><strong>Basic strings</strong> are surrounded by quotation marks. Any Unicode character may
be used except those that must be escaped: quotation mark, backslash, and the
control characters other than tab (U+0000 to U+0008, U+000A to U+001F, U+007F).</p>
<pre><code class="code language-toml" data-controller="snippet">str = &quot;I'm a string. \&quot;You can quote me\&quot;. Name\tJos\u00E9\nLocation\tSF.&quot;
</code></pre>
<p class="my-4" $1>For convenience, some popular characters have a compact escape sequence.</p>
<pre><code>\b         - backspace       (U+0008)
\t         - tab             (U+0009)
\n         - linefeed        (U+000A)
\f         - form feed       (U+000C)
\r         - carriage return (U+000D)
\&quot;         - quote           (U+0022)
\\         - backslash       (U+005C)
\uXXXX     - unicode         (U+XXXX)
\UXXXXXXXX - unicode         (U+XXXXXXXX)
</code></pre>
<p class="my-4" $1>Any Unicode character may be escaped with the <code>\uXXXX</code> or <code>\UXXXXXXXX</code> forms.
The escape codes must be valid Unicode <a href="http://unicode.org/glossary/#unicode_scalar_value">scalar values</a>.</p>
<p class="my-4" $1>All other escape sequences not listed above are reserved and, if used, TOML
should produce an error.</p>
<p class="my-4" $1>Sometimes you need to express passages of text (e.g. translation files) or would
like to break up a very long string into multiple lines. TOML makes this easy.</p>
<p class="my-4" $1><strong>Multi-line basic strings</strong> are surrounded by three quotation marks on each
side and allow newlines. A newline immediately following the opening delimiter
will be trimmed. All other whitespace and newline characters remain intact.</p>
<pre><code class="code language-toml" data-controller="snippet">str1 = &quot;&quot;&quot;
Roses are red
Violets are blue&quot;&quot;&quot;
</code></pre>
<p class="my-4" $1>TOML parsers should feel free to normalize newline to whatever makes sense for
their platform.</p>
<pre><code class="code language-toml" data-controller="snippet"># On a Unix system, the above multi-line string will most likely be the same as:
str2 = &quot;Roses are red\nViolets are blue&quot;

# On a Windows system, it will most likely be equivalent to:
str3 = &quot;Roses are red\r\nViolets are blue&quot;
</code></pre>
<p class="my-4" $1>For writing long strings without introducing extraneous whitespace, use a &quot;line
ending backslash&quot;. When the last non-whitespace character on a line is a <code>\</code>, it
will be trimmed along with all whitespace (including newlines) up to the next
non-whitespace character or closing delimiter. All of the escape sequences that
are valid for basic strings are also valid for multi-line basic strings.</p>
<pre><code class="code language-toml" data-controller="snippet"># The following strings are byte-for-byte equivalent:
str1 = &quot;The quick brown fox jumps over the lazy dog.&quot;

str2 = &quot;&quot;&quot;
The quick brown \


  fox jumps over \
    the lazy dog.&quot;&quot;&quot;

str3 = &quot;&quot;&quot;\
       The quick brown \
       fox jumps over \
       the lazy dog.\
       &quot;&quot;&quot;
</code></pre>
<p class="my-4" $1>Any Unicode character may be used except those that must be escaped: backslash
and the control characters other than tab, line feed, and carriage return
(U+0000 to U+0008, U+000B, U+000C, U+000E to U+001F, U+007F). Quotation marks
need not be escaped unless their presence would create a premature closing
delimiter.</p>
<p class="my-4" $1>If you're a frequent specifier of Windows paths or regular expressions, then
having to escape backslashes quickly becomes tedious and error prone. To help,
TOML supports literal strings which do not allow escaping at all.</p>
<p class="my-4" $1><strong>Literal strings</strong> are surrounded by single quotes. Like basic strings, they
must appear on a single line:</p>
<pre><code class="code language-toml" data-controller="snippet"># What you see is what you get.
winpath  = 'C:\Users\nodejs\templates'
winpath2 = '\\ServerX\admin$\system32\'
quoted   = 'Tom &quot;Dubs&quot; Preston-Werner'
regex    = '&lt;\i\c*\s*&gt;'
</code></pre>
<p class="my-4" $1>Since there is no escaping, there is no way to write a single quote inside a
literal string enclosed by single quotes. Luckily, TOML supports a multi-line
version of literal strings that solves this problem.</p>
<p class="my-4" $1><strong>Multi-line literal strings</strong> are surrounded by three single quotes on each
side and allow newlines. Like literal strings, there is no escaping whatsoever.
A newline immediately following the opening delimiter will be trimmed. All
other content between the delimiters is interpreted as-is without modification.</p>
<pre><code class="code language-toml" data-controller="snippet">regex2 = '''I [dw]on't need \d{2} apples'''
lines  = '''
The first newline is
trimmed in raw strings.
   All other whitespace
   is preserved.
'''
</code></pre>
<p class="my-4" $1>Control characters other than tab are not permitted in a literal string. Thus,
for binary data it is recommended that you use Base64 or another suitable ASCII
or UTF-8 encoding. The handling of that encoding will be application specific.</p>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="integer">Integer</h2>
<p class="my-4" $1>Integers are whole numbers. Positive numbers may be prefixed with a plus sign.
Negative numbers are prefixed with a minus sign.</p>
<pre><code class="code language-toml" data-controller="snippet">int1 = +99
int2 = 42
int3 = 0
int4 = -17
</code></pre>
<p class="my-4" $1>For large numbers, you may use underscores between digits to enhance
readability. Each underscore must be surrounded by at least one digit on each
side.</p>
<pre><code class="code language-toml" data-controller="snippet">int5 = 1_000
int6 = 5_349_221
int7 = 1_2_3_4_5     # VALID but discouraged
</code></pre>
<p class="my-4" $1>Leading zeros are not allowed. Integer values <code>-0</code> and <code>+0</code> are valid and
identical to an unprefixed zero.</p>
<p class="my-4" $1>Non-negative integer values may also be expressed in hexadecimal, octal, or
binary. In these formats, leading <code>+</code> is not allowed and leading zeros are
allowed (after the prefix). Hex values are case insensitive. Underscores are
allowed between digits (but not between the prefix and the value).</p>
<pre><code class="code language-toml" data-controller="snippet"># hexadecimal with prefix `0x`
hex1 = 0xDEADBEEF
hex2 = 0xdeadbeef
hex3 = 0xdead_beef

# octal with prefix `0o`
oct1 = 0o01234567
oct2 = 0o755 # useful for Unix file permissions

# binary with prefix `0b`
bin1 = 0b11010110
</code></pre>
<p class="my-4" $1>64 bit (signed long) range expected (−9,223,372,036,854,775,808 to
9,223,372,036,854,775,807).</p>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="float">Float</h2>
<p class="my-4" $1>Floats should be implemented as IEEE 754 binary64 values.</p>
<p class="my-4" $1>A float consists of an integer part (which follows the same rules as decimal
integer values) followed by a fractional part and/or an exponent part. If both a
fractional part and exponent part are present, the fractional part must precede
the exponent part.</p>
<pre><code class="code language-toml" data-controller="snippet"># fractional
flt1 = +1.0
flt2 = 3.1415
flt3 = -0.01

# exponent
flt4 = 5e+22
flt5 = 1e06
flt6 = -2E-2

# both
flt7 = 6.626e-34
</code></pre>
<p class="my-4" $1>A fractional part is a decimal point followed by one or more digits.</p>
<p class="my-4" $1>An exponent part is an E (upper or lower case) followed by an integer part
(which follows the same rules as decimal integer values but may include leading
zeros).</p>
<p class="my-4" $1>Similar to integers, you may use underscores to enhance readability. Each
underscore must be surrounded by at least one digit.</p>
<pre><code class="code language-toml" data-controller="snippet">flt8 = 224_617.445_991_228
</code></pre>
<p class="my-4" $1>Float values <code>-0.0</code> and <code>+0.0</code> are valid and should map according to IEEE 754.</p>
<p class="my-4" $1>Special float values can also be expressed. They are always lowercase.</p>
<pre><code class="code language-toml" data-controller="snippet"># infinity
sf1 = inf  # positive infinity
sf2 = +inf # positive infinity
sf3 = -inf # negative infinity

# not a number
sf4 = nan  # actual sNaN/qNaN encoding is implementation specific
sf5 = +nan # same as `nan`
sf6 = -nan # valid, actual encoding is implementation specific
</code></pre>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="boolean">Boolean</h2>
<p class="my-4" $1>Booleans are just the tokens you're used to. Always lowercase.</p>
<pre><code class="code language-toml" data-controller="snippet">bool1 = true
bool2 = false
</code></pre>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="offset-date-time">Offset Date-Time</h2>
<p class="my-4" $1>To unambiguously represent a specific instant in time, you may use an
<a href="http://tools.ietf.org/html/rfc3339">RFC 3339</a> formatted date-time with offset.</p>
<pre><code class="code language-toml" data-controller="snippet">odt1 = 1979-05-27T07:32:00Z
odt2 = 1979-05-27T00:32:00-07:00
odt3 = 1979-05-27T00:32:00.999999-07:00
</code></pre>
<p class="my-4" $1>For the sake of readability, you may replace the T delimiter between date and
time with a space (as permitted by RFC 3339 section 5.6).</p>
<pre><code class="code language-toml" data-controller="snippet">odt4 = 1979-05-27 07:32:00Z
</code></pre>
<p class="my-4" $1>The precision of fractional seconds is implementation specific, but at least
millisecond precision is expected. If the value contains greater precision than
the implementation can support, the additional precision must be truncated, not
rounded.</p>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="local-date-time">Local Date-Time</h2>
<p class="my-4" $1>If you omit the offset from an <a href="http://tools.ietf.org/html/rfc3339">RFC 3339</a>
formatted date-time, it will represent the given date-time without any relation
to an offset or timezone. It cannot be converted to an instant in time without
additional information. Conversion to an instant, if required, is implementation
specific.</p>
<pre><code class="code language-toml" data-controller="snippet">ldt1 = 1979-05-27T07:32:00
ldt2 = 1979-05-27T00:32:00.999999
</code></pre>
<p class="my-4" $1>The precision of fractional seconds is implementation specific, but at least
millisecond precision is expected. If the value contains greater precision than
the implementation can support, the additional precision must be truncated, not
rounded.</p>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="local-date">Local Date</h2>
<p class="my-4" $1>If you include only the date portion of an
<a href="http://tools.ietf.org/html/rfc3339">RFC 3339</a> formatted date-time, it will
represent that entire day without any relation to an offset or timezone.</p>
<pre><code class="code language-toml" data-controller="snippet">ld1 = 1979-05-27
</code></pre>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="local-time">Local Time</h2>
<p class="my-4" $1>If you include only the time portion of an <a href="http://tools.ietf.org/html/rfc3339">RFC
3339</a> formatted date-time, it will represent
that time of day without any relation to a specific day or any offset or
timezone.</p>
<pre><code class="code language-toml" data-controller="snippet">lt1 = 07:32:00
lt2 = 00:32:00.999999
</code></pre>
<p class="my-4" $1>The precision of fractional seconds is implementation specific, but at least
millisecond precision is expected. If the value contains greater precision than
the implementation can support, the additional precision must be truncated, not
rounded.</p>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="array">Array</h2>
<p class="my-4" $1>Arrays are square brackets with values inside. Whitespace is ignored. Elements
are separated by commas. Data types may not be mixed (different ways to define
strings should be considered the same type, and so should arrays with different
element types).</p>
<pre><code class="code language-toml" data-controller="snippet">arr1 = [ 1, 2, 3 ]
arr2 = [ &quot;red&quot;, &quot;yellow&quot;, &quot;green&quot; ]
arr3 = [ [ 1, 2 ], [3, 4, 5] ]
arr4 = [ &quot;all&quot;, 'strings', &quot;&quot;&quot;are the same&quot;&quot;&quot;, '''type''']
arr5 = [ [ 1, 2 ], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] ]

arr6 = [ 1, 2.0 ] # INVALID
</code></pre>
<p class="my-4" $1>Arrays can also be multiline. A terminating comma (also called trailing comma)
is ok after the last value of the array. There can be an arbitrary number of
newlines and comments before a value and before the closing bracket.</p>
<pre><code class="code language-toml" data-controller="snippet">arr7 = [
  1, 2, 3
]

arr8 = [
  1,
  2, # this is ok
]
</code></pre>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="table">Table</h2>
<p class="my-4" $1>Tables (also known as hash tables or dictionaries) are collections of key/value
pairs. They appear in square brackets on a line by themselves. You can tell them
apart from arrays because arrays are only ever values.</p>
<pre><code class="code language-toml" data-controller="snippet">[table]
</code></pre>
<p class="my-4" $1>Under that, and until the next table or EOF are the key/values of that table.
Key/value pairs within tables are not guaranteed to be in any specific order.</p>
<pre><code class="code language-toml" data-controller="snippet">[table-1]
key1 = &quot;some string&quot;
key2 = 123

[table-2]
key1 = &quot;another string&quot;
key2 = 456
</code></pre>
<p class="my-4" $1>Naming rules for tables are the same as for keys (see definition of Keys above).</p>
<pre><code class="code language-toml" data-controller="snippet">[dog.&quot;tater.man&quot;]
type.name = &quot;pug&quot;
</code></pre>
<p class="my-4" $1>In JSON land, that would give you the following structure:</p>
<pre><code class="code language-json" data-controller="snippet">{ &quot;dog&quot;: { &quot;tater.man&quot;: { &quot;type&quot;: { &quot;name&quot;: &quot;pug&quot; } } } }
</code></pre>
<p class="my-4" $1>Whitespace around the key is ignored, however, best practice is to not use any
extraneous whitespace.</p>
<pre><code class="code language-toml" data-controller="snippet">[a.b.c]            # this is best practice
[ d.e.f ]          # same as [d.e.f]
[ g .  h  . i ]    # same as [g.h.i]
[ j . &quot;ʞ&quot; . 'l' ]  # same as [j.&quot;ʞ&quot;.'l']
</code></pre>
<p class="my-4" $1>You don't need to specify all the super-tables if you don't want to. TOML knows
how to do it for you.</p>
<pre><code class="code language-toml" data-controller="snippet"># [x] you
# [x.y] don't
# [x.y.z] need these
[x.y.z.w] # for this to work

[x] # defining a super-table afterwards is ok
</code></pre>
<p class="my-4" $1>Empty tables are allowed and simply have no key/value pairs within them.</p>
<p class="my-4" $1>Like keys, you cannot define any table more than once. Doing so is invalid.</p>
<pre><code># DO NOT DO THIS

[a]
b = 1

[a]
c = 2
</code></pre>
<pre><code># DO NOT DO THIS EITHER

[a]
b = 1

[a.b]
c = 2
</code></pre>
<p class="my-4" $1>Defining tables out-of-order is discouraged.</p>
<pre><code class="code language-toml" data-controller="snippet"># VALID BUT DISCOURAGED
[a.x]
[b]
[a.y]
</code></pre>
<pre><code class="code language-toml" data-controller="snippet"># RECOMMENDED
[a.x]
[a.y]
[b]
</code></pre>
<p class="my-4" $1>Dotted keys define everything to the left of each dot as a table. Since tables
cannot be defined more than once, redefining such tables using a <code>[table]</code>
header is not allowed. Likewise, using dotted keys to redefine tables already
defined in <code>[table]</code> form is not allowed.</p>
<p class="my-4" $1>The <code>[table]</code> form can, however, be used to define sub-tables within tables
defined via dotted keys.</p>
<pre><code class="code language-toml" data-controller="snippet">[fruit]
apple.color = &quot;red&quot;
apple.taste.sweet = true

# [fruit.apple]  # INVALID
# [fruit.apple.taste]  # INVALID

[fruit.apple.texture]  # you can add sub-tables
smooth = true
</code></pre>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="inline-table">Inline Table</h2>
<p class="my-4" $1>Inline tables provide a more compact syntax for expressing tables. They are
especially useful for grouped data that can otherwise quickly become verbose.
Inline tables are enclosed in curly braces <code>{</code> and <code>}</code>. Within the braces, zero
or more comma separated key/value pairs may appear. Key/value pairs take the
same form as key/value pairs in standard tables. All value types are allowed,
including inline tables.</p>
<p class="my-4" $1>Inline tables are intended to appear on a single line. No newlines are allowed
between the curly braces unless they are valid within a value. Even so, it is
strongly discouraged to break an inline table onto multiples lines. If you find
yourself gripped with this desire, it means you should be using standard tables.</p>
<pre><code class="code language-toml" data-controller="snippet">name = { first = &quot;Tom&quot;, last = &quot;Preston-Werner&quot; }
point = { x = 1, y = 2 }
animal = { type.name = &quot;pug&quot; }
</code></pre>
<p class="my-4" $1>The inline tables above are identical to the following standard table
definitions:</p>
<pre><code class="code language-toml" data-controller="snippet">[name]
first = &quot;Tom&quot;
last = &quot;Preston-Werner&quot;

[point]
x = 1
y = 2

[animal]
type.name = &quot;pug&quot;

</code></pre>
<p class="my-4" $1>Inline tables fully define the keys and sub-tables within them. New keys and
sub-tables cannot be added to them.</p>
<pre><code class="code language-toml" data-controller="snippet">[product]
type = { name = &quot;Nail&quot; }
# type.edible = false  # INVALID
</code></pre>
<p class="my-4" $1>Similarly, inline tables can not be used to add keys or sub-tables to an
already-defined table.</p>
<pre><code class="code language-toml" data-controller="snippet">[product]
type.name = &quot;Nail&quot;
# type = { edible = false }  # INVALID
</code></pre>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="array-of-tables">Array of Tables</h2>
<p class="my-4" $1>The last type that has not yet been expressed is an array of tables. These can
be expressed by using a table name in double brackets. Each table with the same
double bracketed name will be an element in the array. The tables are inserted
in the order encountered. A double bracketed table without any key/value pairs
will be considered an empty table.</p>
<pre><code class="code language-toml" data-controller="snippet">[[products]]
name = &quot;Hammer&quot;
sku = 738594937

[[products]]

[[products]]
name = &quot;Nail&quot;
sku = 284758393
color = &quot;gray&quot;
</code></pre>
<p class="my-4" $1>In JSON land, that would give you the following structure.</p>
<pre><code class="code language-json" data-controller="snippet">{
  &quot;products&quot;: [
    { &quot;name&quot;: &quot;Hammer&quot;, &quot;sku&quot;: 738594937 },
    { },
    { &quot;name&quot;: &quot;Nail&quot;, &quot;sku&quot;: 284758393, &quot;color&quot;: &quot;gray&quot; }
  ]
}
</code></pre>
<p class="my-4" $1>You can create nested arrays of tables as well. Just use the same double bracket
syntax on sub-tables. Each double-bracketed sub-table will belong to the most
recently defined table element above it.</p>
<pre><code class="code language-toml" data-controller="snippet">[[fruit]]
  name = &quot;apple&quot;

  [fruit.physical]
    color = &quot;red&quot;
    shape = &quot;round&quot;

  [[fruit.variety]]
    name = &quot;red delicious&quot;

  [[fruit.variety]]
    name = &quot;granny smith&quot;

[[fruit]]
  name = &quot;banana&quot;

  [[fruit.variety]]
    name = &quot;plantain&quot;
</code></pre>
<p class="my-4" $1>The above TOML maps to the following JSON.</p>
<pre><code class="code language-json" data-controller="snippet">{
  &quot;fruit&quot;: [
    {
      &quot;name&quot;: &quot;apple&quot;,
      &quot;physical&quot;: {
        &quot;color&quot;: &quot;red&quot;,
        &quot;shape&quot;: &quot;round&quot;
      },
      &quot;variety&quot;: [
        { &quot;name&quot;: &quot;red delicious&quot; },
        { &quot;name&quot;: &quot;granny smith&quot; }
      ]
    },
    {
      &quot;name&quot;: &quot;banana&quot;,
      &quot;variety&quot;: [
        { &quot;name&quot;: &quot;plantain&quot; }
      ]
    }
  ]
}
</code></pre>
<p class="my-4" $1>Attempting to append to a statically defined array, even if that array is empty
or of compatible type, must produce an error at parse time.</p>
<pre><code class="code language-toml" data-controller="snippet"># INVALID TOML DOC
fruit = []

[[fruit]] # Not allowed
</code></pre>
<p class="my-4" $1>Attempting to define a normal table with the same name as an already established
array must produce an error at parse time.</p>
<pre><code># INVALID TOML DOC
[[fruit]]
  name = &quot;apple&quot;

  [[fruit.variety]]
    name = &quot;red delicious&quot;

  # This table conflicts with the previous table
  [fruit.variety]
    name = &quot;granny smith&quot;
</code></pre>
<p class="my-4" $1>You may also use inline tables where appropriate:</p>
<pre><code class="code language-toml" data-controller="snippet">points = [ { x = 1, y = 2, z = 3 },
           { x = 7, y = 8, z = 9 },
           { x = 2, y = 4, z = 8 } ]
</code></pre>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="filename-extension">Filename Extension</h2>
<p class="my-4" $1>TOML files should use the extension <code>.toml</code>.</p>
<h2 class="text-2xl font-semibold text-orange-800 pt-16" id="mime-type">MIME Type</h2>
<p class="my-4" $1>When transferring TOML files over the internet, the appropriate MIME type is
<code>application/toml</code>.</p>
